<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Template Player (Slots + Texture Swap)</title>
  <style>
    html,body { margin:0; height:100%; background:#111; color:#ddd; font-family:system-ui; }
    #ui {
      position:fixed; top:10px; left:10px; right:10px;
      display:flex; flex-wrap:wrap; gap:8px; align-items:center;
      z-index:10; background:rgba(0,0,0,.35); padding:10px; border-radius:10px;
      backdrop-filter: blur(6px);
    }
    button,input,select { padding:6px 10px; }
    #stage { width:100vw; height:100vh; }
    .label { opacity:.8; font-size:12px; }
  </style>
</head>
<body>
  <div id="ui">
    <div>
      <div class="label">ãƒ†ãƒ³ãƒ—ãƒ¬JSON</div>
      <input id="jsonFile" type="file" accept="application/json" />
    </div>

    <div>
  <div class="label">å†…è”µãƒ†ãƒ³ãƒ—ãƒ¬</div>
  <select id="builtinSelect"></select>
</div>
<button id="loadBuiltin">å†…è”µãƒ†ãƒ³ãƒ—ãƒ¬é©ç”¨</button>
<button id="exportTemplate">ä»Šã®ãƒ†ãƒ³ãƒ—ãƒ¬ã‚’æ›¸ãå‡ºã—</button>

    <div>
      <div class="label">å·®ã—æ›¿ãˆå…ˆã‚¹ãƒ­ãƒƒãƒˆ</div>
      <select id="slotSelect"></select>
    </div>

    <div>
  <div class="label">ãƒ‘ãƒ¼ãƒ„ãƒ•ã‚©ãƒ«ãƒ€ä¸€æ‹¬èª­ã¿è¾¼ã¿</div>
  <input id="folder" type="file" webkitdirectory multiple />
</div>
<button id="applyFolder">ãƒ•ã‚©ãƒ«ãƒ€ã‚’å…¨éƒ¨åæ˜ </button>

    <div>
      <div class="label">ç”»åƒ(PNG/WebP/JPG)</div>
      <input id="imgFile" type="file" accept="image/*" />
    </div>

    <button id="applyImg">å·®ã—æ›¿ãˆ</button>
    <button id="resetSlot">ã“ã®ã‚¹ãƒ­ãƒƒãƒˆã‚’ãƒªã‚»ãƒƒãƒˆ</button>

    <span style="flex:1"></span>

    <button id="play">Play</button>
    <button id="pause">Pause</button>
    <button id="restart">Restart</button>
  </div>

  <div id="stage"></div>

  <script src="https://cdn.jsdelivr.net/npm/pixi.js@8/dist/pixi.min.js"></script>
  <script>
    // ---- Helpers ----
    const clamp01 = (x) => Math.max(0, Math.min(1, x));
    const toRad = (deg) => deg * Math.PI / 180;

    function hexToRgba(hex) {
      if (typeof hex !== "string" || !hex.startsWith("#")) return { r:255, g:255, b:255, a:1 };
      const h = hex.slice(1);
      if (h.length === 8) {
        const a = parseInt(h.slice(0,2), 16) / 255;
        const r = parseInt(h.slice(2,4), 16);
        const g = parseInt(h.slice(4,6), 16);
        const b = parseInt(h.slice(6,8), 16);
        return { r,g,b,a };
      }
      if (h.length === 6) {
        const r = parseInt(h.slice(0,2), 16);
        const g = parseInt(h.slice(2,4), 16);
        const b = parseInt(h.slice(4,6), 16);
        return { r,g,b,a:1 };
      }
      return { r:255, g:255, b:255, a:1 };
    }
    const rgbToTint = (r,g,b) => (r<<16) | (g<<8) | b;

    // ---- Cubic Bezier easing (minimal) ----
    function makeCubicBezier(x1, y1, x2, y2) {
      const cx = 3*x1, bx = 3*(x2-x1)-cx, ax = 1-cx-bx;
      const cy = 3*y1, by = 3*(y2-y1)-cy, ay = 1-cy-by;
      const sampleX = (t)=>((ax*t+bx)*t+cx)*t;
      const sampleY = (t)=>((ay*t+by)*t+cy)*t;
      const derivX  = (t)=>(3*ax*t+2*bx)*t+cx;

      function solveX(x) {
        let t = x;
        for (let i=0;i<6;i++){
          const dx = sampleX(t)-x;
          const d  = derivX(t);
          if (Math.abs(dx) < 1e-6) return t;
          if (Math.abs(d)  < 1e-6) break;
          t = t - dx/d;
        }
        let t0=0,t1=1; t=x;
        for (let i=0;i<20;i++){
          const dx = sampleX(t)-x;
          if (Math.abs(dx) < 1e-6) return t;
          if (dx > 0) t1=t; else t0=t;
          t = (t0+t1)/2;
        }
        return t;
      }
      return (x)=>{
        x = clamp01(x);
        const t = solveX(x);
        return clamp01(sampleY(t));
      };
    }
    function parseEase(e) {
      if (!e) return null;
      const m = String(e).match(/^cubicBezier\(([-\d.]+),([-\d.]+),([-\d.]+),([-\d.]+)\)$/);
      if (!m) return null;
      return makeCubicBezier(+m[1],+m[2],+m[3],+m[4]);
    }

    // ---- Keyframe sampling ----
    function sampleTrack(track, t) {
      if (!track || track.length === 0) return null;
      if (t <= track[0].t) return track[0].v;
      if (t >= track[track.length-1].t) return track[track.length-1].v;

      let i=0;
      for (; i<track.length-1; i++){
        if (t >= track[i].t && t <= track[i+1].t) break;
      }
      const k0 = track[i], k1 = track[i+1];
      const span = (k1.t - k0.t) || 1e-6;
      let u = (t - k0.t) / span;

      // cubicBezierã®ã¿å¯¾å¿œã€‚localç³»ã¯ç„¡è¦–ï¼linear
      const easeFn = parseEase(k1.ease) || parseEase(k0.ease);
      if (easeFn) u = easeFn(u);

      const v0 = k0.v, v1 = k1.v;

      if (typeof v0 === "number" && typeof v1 === "number")
        return v0 + (v1 - v0) * u;

      if (Array.isArray(v0) && Array.isArray(v1)) {
        const n = Math.min(v0.length, v1.length);
        const out = new Array(n);
        for (let j=0; j<n; j++) out[j] = v0[j] + (v1[j] - v0[j]) * u;
        return out;
      }

      if (typeof v0 === "string" && typeof v1 === "string")
        return (u < 0.5) ? v0 : v1;

      return v0;
    }

    // ---- Pixi setup ----
    const app = new PIXI.Application();
    await app.init({ resizeTo: window, backgroundAlpha: 0, antialias: true });
    document.getElementById("stage").appendChild(app.canvas);

    const BUILTIN_TEMPLATES = [
  {
    id: "static_base",
    name: "ç´ ä½“ï¼ˆé™æ­¢ï¼‰",
    data: {
      {
  "meta": {
    "title": "Chibi Template",
    "fps": 12,
    "duration": 2,
    "loop": true
  },
  "slots": {
    "effect/exclamation": {
      "label": "ï¼ãƒãƒ¼ã‚¯",
      "baseSize": {
        "w": 1024,
        "h": 1024
      },
      "fit": "contain",
      "z": 1000
    },
    "effect/question": {
      "label": "ï¼Ÿãƒãƒ¼ã‚¯",
      "baseSize": {
        "w": 1024,
        "h": 1024
      },
      "fit": "contain",
      "z": 999
    },
    "effect/heart": {
      "label": "ãƒãƒ¼ãƒˆ",
      "baseSize": {
        "w": 1024,
        "h": 1024
      },
      "fit": "contain",
      "z": 998
    },
    "effect/star": {
      "label": "ã‚¹ã‚¿ãƒ¼",
      "baseSize": {
        "w": 1024,
        "h": 1024
      },
      "fit": "contain",
      "z": 997
    },
    "effect/impact": {
      "label": "è¡æ’ƒ",
      "baseSize": {
        "w": 1024,
        "h": 1024
      },
      "fit": "contain",
      "z": 996
    },
    "effect/notice": {
      "label": "æ°—ä»˜ã",
      "baseSize": {
        "w": 1024,
        "h": 1024
      },
      "fit": "contain",
      "z": 995
    },
    "outer/head/catyusha": {
      "label": "ã‚«ãƒãƒ¥ãƒ¼ã‚·ãƒ£",
      "baseSize": {
        "w": 1024,
        "h": 1024
      },
      "fit": "contain",
      "z": 981
    },
    "outer/head/headphone": {
      "label": "ãƒ˜ãƒƒãƒ‰ãƒ›ãƒ³",
      "baseSize": {
        "w": 1024,
        "h": 1024
      },
      "fit": "contain",
      "z": 980
    },
    "outer/face/square": {
      "label": "å››è§’",
      "baseSize": {
        "w": 1024,
        "h": 1024
      },
      "fit": "contain",
      "z": 979
    },
    "outer/face/glasses": {
      "label": "çœ¼é¡",
      "baseSize": {
        "w": 1024,
        "h": 1024
      },
      "fit": "contain",
      "z": 978
    },
    "outer/body/muffler": {
      "label": "ãƒãƒ•ãƒ©ãƒ¼",
      "baseSize": {
        "w": 1024,
        "h": 1024
      },
      "fit": "contain",
      "z": 977
    },
    "outer/right_hand/hand": {
      "label": "å³æ‰‹ æ‰‹",
      "baseSize": {
        "w": 1024,
        "h": 1024
      },
      "fit": "contain",
      "z": 970
    },
    "outer/right_hand/stick": {
      "label": "å³æ‰‹ ã‚¹ãƒ†ã‚£ãƒƒã‚¯",
      "baseSize": {
        "w": 1024,
        "h": 1024
      },
      "fit": "contain",
      "z": 969
    },
    "outer/right_hand/ball": {
      "label": "å³æ‰‹ ãƒœãƒ¼ãƒ«",
      "baseSize": {
        "w": 1024,
        "h": 1024
      },
      "fit": "contain",
      "z": 968
    },
    "outer/left_hand/hand": {
      "label": "å·¦æ‰‹ æ‰‹",
      "baseSize": {
        "w": 1024,
        "h": 1024
      },
      "fit": "contain",
      "z": 967
    },
    "outer/left_hand/stick": {
      "label": "å·¦æ‰‹ ã‚¹ãƒ†ã‚£ãƒƒã‚¯",
      "baseSize": {
        "w": 1024,
        "h": 1024
      },
      "fit": "contain",
      "z": 966
    },
    "outer/left_hand/ball": {
      "label": "å·¦æ‰‹ ãƒœãƒ¼ãƒ«",
      "baseSize": {
        "w": 1024,
        "h": 1024
      },
      "fit": "contain",
      "z": 965
    },
    "emotion/angry": {
      "label": "æ€’",
      "baseSize": {
        "w": 1024,
        "h": 1024
      },
      "fit": "contain",
      "z": 930
    },
    "emotion/doubt": {
      "label": "ç–‘",
      "baseSize": {
        "w": 1024,
        "h": 1024
      },
      "fit": "contain",
      "z": 929
    },
    "emotion/blush": {
      "label": "èµ¤é¢",
      "baseSize": {
        "w": 1024,
        "h": 1024
      },
      "fit": "contain",
      "z": 928
    },
    "emotion/ear_blush": {
      "label": "è€³èµ¤",
      "baseSize": {
        "w": 1024,
        "h": 1024
      },
      "fit": "contain",
      "z": 927
    },
    "emotion/cheek": {
      "label": "ã»ã£ãº",
      "baseSize": {
        "w": 1024,
        "h": 1024
      },
      "fit": "contain",
      "z": 926
    },
    "emotion/sweat/3": {
      "label": "æ±— 3æ®µéš",
      "baseSize": {
        "w": 1024,
        "h": 1024
      },
      "fit": "contain",
      "z": 925
    },
    "emotion/sweat/2": {
      "label": "æ±— 2æ®µéš",
      "baseSize": {
        "w": 1024,
        "h": 1024
      },
      "fit": "contain",
      "z": 924
    },
    "emotion/sweat/1": {
      "label": "æ±— 1æ®µéš",
      "baseSize": {
        "w": 1024,
        "h": 1024
      },
      "fit": "contain",
      "z": 923
    },
    "emotion/tears": {
      "label": "æ¶™",
      "baseSize": {
        "w": 1024,
        "h": 1024
      },
      "fit": "contain",
      "z": 922
    },
    "mouth/oo": {
      "label": "ãŠãŠ",
      "baseSize": {
        "w": 1024,
        "h": 1024
      },
      "fit": "contain",
      "z": 900
    },
    "mouth/o": {
      "label": "ãŠ",
      "baseSize": {
        "w": 1024,
        "h": 1024
      },
      "fit": "contain",
      "z": 899
    },
    "mouth/e": {
      "label": "ãˆ",
      "baseSize": {
        "w": 1024,
        "h": 1024
      },
      "fit": "contain",
      "z": 898
    },
    "mouth/u": {
      "label": "ã†",
      "baseSize": {
        "w": 1024,
        "h": 1024
      },
      "fit": "contain",
      "z": 897
    },
    "mouth/yu": {
      "label": "ã‚†",
      "baseSize": {
        "w": 1024,
        "h": 1024
      },
      "fit": "contain",
      "z": 896
    },
    "mouth/ni": {
      "label": "ã«",
      "baseSize": {
        "w": 1024,
        "h": 1024
      },
      "fit": "contain",
      "z": 895
    },
    "mouth/i": {
      "label": "ã„",
      "baseSize": {
        "w": 1024,
        "h": 1024
      },
      "fit": "contain",
      "z": 894
    },
    "mouth/a": {
      "label": "ã‚",
      "baseSize": {
        "w": 1024,
        "h": 1024
      },
      "fit": "contain",
      "z": 893
    },
    "mouth/n_smile": {
      "label": "ã‚“ãƒğŸ™‚",
      "baseSize": {
        "w": 1024,
        "h": 1024
      },
      "fit": "contain",
      "z": 892
    },
    "mouth/n_frown": {
      "label": "ã‚“ã…ğŸ™",
      "baseSize": {
        "w": 1024,
        "h": 1024
      },
      "fit": "contain",
      "z": 891
    },
    "mouth/n_neutral": {
      "label": "ã‚“ğŸ˜¶",
      "baseSize": {
        "w": 1024,
        "h": 1024
      },
      "fit": "contain",
      "z": 890
    },
    "eye/right/upper_close": {
      "label": "ç›® å³ ä¸Šé–‰",
      "baseSize": {
        "w": 1024,
        "h": 1024
      },
      "fit": "contain",
      "z": 880
    },
    "eye/right/lower_close": {
      "label": "ç›® å³ ä¸‹é–‰",
      "baseSize": {
        "w": 1024,
        "h": 1024
      },
      "fit": "contain",
      "z": 879
    },
    "eye/right/normal": {
      "label": "ç›® å³ æ™®",
      "baseSize": {
        "w": 1024,
        "h": 1024
      },
      "fit": "contain",
      "z": 878
    },
    "eye/right/surprise": {
      "label": "ç›® å³ é©š",
      "baseSize": {
        "w": 1024,
        "h": 1024
      },
      "fit": "contain",
      "z": 877
    },
    "eye/right/thin": {
      "label": "ç›® å³ ç´°",
      "baseSize": {
        "w": 1024,
        "h": 1024
      },
      "fit": "contain",
      "z": 876
    },
    "eye/left/upper_close": {
      "label": "ç›® å·¦ ä¸Šé–‰",
      "baseSize": {
        "w": 1024,
        "h": 1024
      },
      "fit": "contain",
      "z": 875
    },
    "eye/left/lower_close": {
      "label": "ç›® å·¦ ä¸‹é–‰",
      "baseSize": {
        "w": 1024,
        "h": 1024
      },
      "fit": "contain",
      "z": 874
    },
    "eye/left/normal": {
      "label": "ç›® å·¦ æ™®",
      "baseSize": {
        "w": 1024,
        "h": 1024
      },
      "fit": "contain",
      "z": 873
    },
    "eye/left/surprise": {
      "label": "ç›® å·¦ é©š",
      "baseSize": {
        "w": 1024,
        "h": 1024
      },
      "fit": "contain",
      "z": 872
    },
    "eye/left/thin": {
      "label": "ç›® å·¦ ç´°",
      "baseSize": {
        "w": 1024,
        "h": 1024
      },
      "fit": "contain",
      "z": 871
    },
    "brow/right/kiri": {
      "label": "çœ‰ å³ ã‚­ãƒª",
      "baseSize": {
        "w": 1024,
        "h": 1024
      },
      "fit": "contain",
      "z": 860
    },
    "brow/right/komari": {
      "label": "çœ‰ å³ å›°",
      "baseSize": {
        "w": 1024,
        "h": 1024
      },
      "fit": "contain",
      "z": 859
    },
    "brow/right/normal": {
      "label": "çœ‰ å³ æ™®",
      "baseSize": {
        "w": 1024,
        "h": 1024
      },
      "fit": "contain",
      "z": 858
    },
    "brow/right/parallel": {
      "label": "çœ‰ å³ å¹³è¡Œ",
      "baseSize": {
        "w": 1024,
        "h": 1024
      },
      "fit": "contain",
      "z": 857
    },
    "brow/left/kiri": {
      "label": "çœ‰ å·¦ ã‚­ãƒª",
      "baseSize": {
        "w": 1024,
        "h": 1024
      },
      "fit": "contain",
      "z": 856
    },
    "brow/left/komari": {
      "label": "çœ‰ å·¦ å›°",
      "baseSize": {
        "w": 1024,
        "h": 1024
      },
      "fit": "contain",
      "z": 855
    },
    "brow/left/normal": {
      "label": "çœ‰ å·¦ æ™®",
      "baseSize": {
        "w": 1024,
        "h": 1024
      },
      "fit": "contain",
      "z": 854
    },
    "brow/left/parallel": {
      "label": "çœ‰ å·¦ å¹³è¡Œ",
      "baseSize": {
        "w": 1024,
        "h": 1024
      },
      "fit": "contain",
      "z": 853
    },
    "hair/front_center": {
      "label": "å‰é«ªã‚»ãƒ³ã‚¿ãƒ¼",
      "baseSize": {
        "w": 1024,
        "h": 1024
      },
      "fit": "contain",
      "z": 820
    },
    "hair/front_side": {
      "label": "å‰é«ªã‚µã‚¤ãƒ‰",
      "baseSize": {
        "w": 1024,
        "h": 1024
      },
      "fit": "contain",
      "z": 819
    },
    "hair/side_1": {
      "label": "æ¨ªé«ª1",
      "baseSize": {
        "w": 1024,
        "h": 1024
      },
      "fit": "contain",
      "z": 818
    },
    "hair/side_2": {
      "label": "æ¨ªé«ª2",
      "baseSize": {
        "w": 1024,
        "h": 1024
      },
      "fit": "contain",
      "z": 817
    },
    "facecolor/shadow": {
      "label": "å½±",
      "baseSize": {
        "w": 1024,
        "h": 1024
      },
      "fit": "contain",
      "z": 780
    },
    "facecolor/pale": {
      "label": "é’ã–ã‚",
      "baseSize": {
        "w": 1024,
        "h": 1024
      },
      "fit": "contain",
      "z": 779
    },
    "facecolor/blush": {
      "label": "èµ¤é¢",
      "baseSize": {
        "w": 1024,
        "h": 1024
      },
      "fit": "contain",
      "z": 778
    },
    "facecolor/red": {
      "label": "èµ¤ã¿",
      "baseSize": {
        "w": 1024,
        "h": 1024
      },
      "fit": "contain",
      "z": 777
    },
    "facecolor/none": {
      "label": "ç„¡",
      "baseSize": {
        "w": 1024,
        "h": 1024
      },
      "fit": "contain",
      "z": 776
    },
    "face/face": {
      "label": "é¡”",
      "baseSize": {
        "w": 1024,
        "h": 1024
      },
      "fit": "contain",
      "z": 740
    },
    "hair2/back": {
      "label": "å¾Œã‚é«ª",
      "baseSize": {
        "w": 1024,
        "h": 1024
      },
      "fit": "contain",
      "z": 700
    },
    "body/jacket": {
      "label": "ä¸Šç€",
      "baseSize": {
        "w": 1024,
        "h": 1024
      },
      "fit": "contain",
      "z": 650
    },
    "body/clothes": {
      "label": "æœ",
      "baseSize": {
        "w": 1024,
        "h": 1024
      },
      "fit": "contain",
      "z": 649
    }
  },
  "tracks": {}
}
  },

  {
    id: "bounce_simple",
    name: "ãƒ†ã‚¹ãƒˆï¼šãµã‚ã£ã¨æ‹¡å¤§ï¼ˆå£ï¼‰",
    data: {
      meta: { title: "Bounce Test", fps: 12, duration: 2, loop: true },
      slots: {
        "mouth/o": { label:"å£ ãŠ", baseSize:{w:1024,h:1024}, fit:"contain", z:899 },
        "face/face": { label:"é¡”", baseSize:{w:1024,h:1024}, fit:"contain", z:740 }
      },
      tracks: {
        "mouth/o": {
          position: [{ t:0, v:[540, 620] }],
          scale: [
            { t:0.0, v:[1.0, 1.0] },
            { t:0.5, v:[1.15, 1.15], ease:"cubicBezier(0,0,0,1)" },
            { t:1.0, v:[1.0, 1.0], ease:"cubicBezier(0,0,0,1)" }
          ]
        },
        "face/face": {
          position: [{ t:0, v:[540, 540] }]
        }
      }
    }
  }
];

    // ---- Player state ----
    let template = null;
    let playing = true;
    let timeSec = 0;
    let durationSec = 2;

    // slotId -> { container, placeholderGraphics, sprite|null }
    const slotNodes = new Map();

    function clearScene() {
      app.stage.removeChildren();
      slotNodes.clear();
      document.getElementById("slotSelect").innerHTML = "";
    }

    function addSlotOption(slotId, label) {
      const sel = document.getElementById("slotSelect");
      const opt = document.createElement("option");
      opt.value = slotId;
      opt.textContent = label ? `${label} (${slotId})` : slotId;
      sel.appendChild(opt);
    }

    function buildPlaceholder(slotId, slot, tracks) {
      const g = new PIXI.Graphics();

      // ãƒ—ãƒ¬ãƒ¼ã‚¹ãƒ›ãƒ«ãƒ€ã‚µã‚¤ã‚ºï¼ˆå¾Œã§slotã«ã‚µã‚¤ã‚ºã‚’å…¥ã‚ŒãŸã‚‰ã“ã“ã‚’åæ˜ ï¼‰
      const w = 220, h = 140;

      const fc = (tracks.fillColor && tracks.fillColor[0]) ? tracks.fillColor[0].v : slot.fillColor;
      const rgba = hexToRgba(fc || "#FFFFFFFF");

      g.clear();
      g.beginFill(rgbToTint(rgba.r, rgba.g, rgba.b), rgba.a);

      if (slot.type === ".circle") g.drawCircle(0, 0, 100);
      else g.drawRect(-w/2, -h/2, w, h);

      g.endFill();
      return g;
    }

    function buildSceneFromTemplate(tpl) {
      clearScene();
      template = tpl;
      durationSec = tpl?.meta?.duration ?? 2;

      slotNodes.set(slotId, { container: c, placeholder, sprite: null });
      
      const slots = tpl.slots || {};
      for (const [slotId, slot] of Object.entries(slots)) {
        const tracks = tpl.tracks?.[slotId] || {};

        // containerã§ã¾ã¨ã‚ã‚‹ï¼ˆå¾Œã§å…¥ã‚Œæ›¿ãˆã—ã‚„ã™ã„ï¼‰
        const c = new PIXI.Container();

        // ã¾ãšãƒ—ãƒ¬ãƒ¼ã‚¹ãƒ›ãƒ«ãƒ€
        const placeholder = buildPlaceholder(slotId, slot, tracks);
        c.addChild(placeholder);

        // anchor/pivotã¯ã€Œã¾ãšä¸­å¿ƒã€å›ºå®šï¼ˆã‚ºãƒ¬ã‚‹å•é¡Œã¯å¾Œã§è©°ã‚ã‚‹ï¼‰
        // Spriteã«ã—ãŸæ™‚ã‚‚ anchor=0.5,0.5 ã§ä¸­å¿ƒåˆã‚ã›ã«ã™ã‚‹

        app.stage.sortableChildren = true;
        app.stage.addChild(c);
        c.zIndex = slot.z ?? 0;

        addSlotOption(slotId, slot.label || slotId);
      }

      // åˆæœŸé©ç”¨
      timeSec = 0;
      applyAtTime(0);
    }

function fitSpriteToBaseSize(sprite, baseSize, fit = "contain") {
  if (!baseSize || !baseSize.w || !baseSize.h) return;

  // ãƒ†ã‚¯ã‚¹ãƒãƒ£æœ¬æ¥ã®ã‚µã‚¤ã‚º
  const tw = sprite.texture.width;
  const th = sprite.texture.height;
  if (!tw || !th) return;

  const sx = baseSize.w / tw;
  const sy = baseSize.h / th;

  let s = 1;
  if (fit === "cover") s = Math.max(sx, sy);
  else if (fit === "stretch") {
    sprite.scale.set(sx, sy);
    return;
  } else {
    // containï¼ˆãƒ‡ãƒ•ã‚©ï¼‰
    s = Math.min(sx, sy);
  }
  sprite.scale.set(s, s);
}
    
function setSlotTexture(slotId, texture) {
  const entry = slotNodes.get(slotId);
  if (!entry) return;

  const slot = template?.slots?.[slotId] || {};

  // æ—¢å­˜spriteå‰Šé™¤
  if (entry.sprite) {
    entry.container.removeChild(entry.sprite);
    entry.sprite.destroy({ children: true });
    entry.sprite = null;
  }

  // placeholderã‚’éš ã™
  entry.placeholder.visible = false;

  // Spriteä½œæˆ
  const sp = new PIXI.Sprite(texture);
  sp.anchor.set(0.5, 0.5); // ä¸­å¿ƒ

  // â˜…ã“ã“ãŒè‚ï¼šã‚¹ãƒ­ãƒƒãƒˆåŸºæº–ã‚µã‚¤ã‚ºã«ãƒ•ã‚£ãƒƒãƒˆï¼ˆãƒ‡ãƒ•ã‚©1024ï¼‰
  fitSpriteToBaseSize(
    sp,
    slot.baseSize || { w: 1024, h: 1024 },
    slot.fit || "contain"
  );

  entry.container.addChild(sp);
  entry.sprite = sp;
}
    
    function resetSlot(slotId) {
      const entry = slotNodes.get(slotId);
      if (!entry) return;
      if (entry.sprite) {
        entry.container.removeChild(entry.sprite);
        entry.sprite.destroy({ children: true });
        entry.sprite = null;
      }
      entry.placeholder.visible = true;
    }

    function slotIdFromFile(file) {
  const rel = file.webkitRelativePath || file.name;
  const p = rel.replace(/\\/g, "/");
  const afterRoot = p.includes("/") ? p.slice(p.indexOf("/") + 1) : p;
  return afterRoot.replace(/\.[^.]+$/, "");
}

async function loadTextureFromFile(file) {
  const url = URL.createObjectURL(file);
  const tex = await PIXI.Assets.load(url);
  setTimeout(() => URL.revokeObjectURL(url), 1000);
  return tex;
}

document.getElementById("applyFolder").onclick = async () => {
  if (!template) return alert("å…ˆã«ãƒ†ãƒ³ãƒ—ãƒ¬JSONã‚’èª­ã¿è¾¼ã‚“ã§");
  const input = document.getElementById("folder");
  const files = Array.from(input.files || []);
  if (!files.length) return alert("ãƒ•ã‚©ãƒ«ãƒ€é¸ã‚“ã§");

  const existingSlots = new Set(Object.keys(template.slots || {}));
  const imgFiles = files.filter(f => /\.(png|webp|jpg|jpeg)$/i.test(f.name));

  let applied = 0;
  for (const f of imgFiles) {
    const slotId = slotIdFromFile(f);
    if (!existingSlots.has(slotId)) {
      console.warn("No slot:", slotId, "from", f.webkitRelativePath || f.name);
      continue;
    }
    const tex = await loadTextureFromFile(f);
    setSlotTexture(slotId, tex);
    applied++;
  }

  applyAtTime(timeSec);
  alert(`åæ˜ : ${applied} / ${imgFiles.length}`);
};

    function applyAtTime(t) {
      if (!template) return;

      for (const [slotId, entry] of slotNodes.entries()) {
        const c = entry.container;
        const tr = template.tracks?.[slotId] || {};

        const pos = sampleTrack(tr.position, t);
        if (pos) c.position.set(pos[0], pos[1]);

        const sc = sampleTrack(tr.scale, t);
        if (sc) c.scale.set(sc[0], sc[1]);

        const rot = sampleTrack(tr.rotation, t);
        if (rot != null) c.rotation = toRad(rot);

        const op = sampleTrack(tr.opacity, t);
        if (op != null) c.alpha = op;

        const sk = sampleTrack(tr.skew, t);
        if (sk) c.skew.set(sk[0], sk[1]);

        // fillColorå¤‰åŒ–ï¼šspriteãŒç„¡ã„ã‚¹ãƒ­ãƒƒãƒˆã ã‘ãƒ—ãƒ¬ãƒ¼ã‚¹ãƒ›ãƒ«ãƒ€å¡—ã‚Šç›´ã—
        if (!entry.sprite) {
          const col = sampleTrack(tr.fillColor, t);
          if (col) {
            const rgba = hexToRgba(col);
            const slot = template.slots[slotId];
            const w = 220, h = 140;
            entry.placeholder.clear();
            entry.placeholder.beginFill(rgbToTint(rgba.r, rgba.g, rgba.b), rgba.a);
            if (slot?.type === ".circle") entry.placeholder.drawCircle(0, 0, 100);
            else entry.placeholder.drawRect(-w/2, -h/2, w, h);
            entry.placeholder.endFill();
          }
        }
      }
    }

    // ---- Loop ----
    let last = performance.now();
    app.ticker.add(() => {
      const now = performance.now();
      const dt = (now - last) / 1000;
      last = now;

      if (playing && template) {
        timeSec += dt;
        if (durationSec > 0 && timeSec > durationSec) timeSec = timeSec % durationSec;
        applyAtTime(timeSec);
      }
    });

    // ---- UI ----
    document.getElementById("play").onclick = () => playing = true;
    document.getElementById("pause").onclick = () => playing = false;
    document.getElementById("restart").onclick = () => { timeSec = 0; applyAtTime(0); };

    function initBuiltinList() {
  const sel = document.getElementById("builtinSelect");
  sel.innerHTML = "";
  for (const t of BUILTIN_TEMPLATES) {
    const opt = document.createElement("option");
    opt.value = t.id;
    opt.textContent = t.name;
    sel.appendChild(opt);
  }
}

function getBuiltinById(id) {
  return BUILTIN_TEMPLATES.find(t => t.id === id) || null;
}

document.getElementById("loadBuiltin").onclick = () => {
  const id = document.getElementById("builtinSelect").value;
  const t = getBuiltinById(id);
  if (!t) return;
  buildSceneFromTemplate(structuredClone(t.data)); // ç ´å£Šé˜²æ­¢
};

document.getElementById("exportTemplate").onclick = () => {
  if (!template) return alert("ãƒ†ãƒ³ãƒ—ãƒ¬ãŒç„¡ã„");
  const blob = new Blob([JSON.stringify(template, null, 2)], { type: "application/json" });
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url;
  a.download = (template.meta?.title || "template") + ".json";
  a.click();
  setTimeout(() => URL.revokeObjectURL(url), 1000);
};

// èµ·å‹•æ™‚ã«1å›å‘¼ã¶
initBuiltinList();

    document.getElementById("jsonFile").addEventListener("change", async (ev) => {
      const file = ev.target.files?.[0];
      if (!file) return;
      const tpl = JSON.parse(await file.text());
      buildSceneFromTemplate(tpl);
    });

    let lastImageFile = null;
    document.getElementById("imgFile").addEventListener("change", (ev) => {
      lastImageFile = ev.target.files?.[0] || null;
    });

    document.getElementById("applyImg").onclick = async () => {
      if (!template) return alert("å…ˆã«ãƒ†ãƒ³ãƒ—ãƒ¬JSONã‚’èª­ã¿è¾¼ã‚“ã§");
      const slotId = document.getElementById("slotSelect").value;
      if (!slotId) return alert("ã‚¹ãƒ­ãƒƒãƒˆé¸ã‚“ã§");
      if (!lastImageFile) return alert("ç”»åƒãƒ•ã‚¡ã‚¤ãƒ«é¸ã‚“ã§");

      const url = URL.createObjectURL(lastImageFile);
      const tex = await PIXI.Assets.load(url);
      setSlotTexture(slotId, tex);

      // ã™ãåæ˜ 
      applyAtTime(timeSec);
    };

    document.getElementById("resetSlot").onclick = () => {
      const slotId = document.getElementById("slotSelect").value;
      if (!slotId) return;
      resetSlot(slotId);
      applyAtTime(timeSec);
    };
  </script>
</body>
</html>
