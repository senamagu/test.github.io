<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Template Player (Slots + Texture Swap)</title>
  <style>
    html,body { margin:0; height:100%; background:#111; color:#ddd; font-family:system-ui; }
    #ui {
      position:fixed; top:10px; left:10px; right:10px;
      display:flex; flex-wrap:wrap; gap:8px; align-items:center;
      z-index:10; background:rgba(0,0,0,.35); padding:10px; border-radius:10px;
      backdrop-filter: blur(6px);
    }
    button,input,select { padding:6px 10px; }
    #stage { width:100vw; height:100vh; }
    .label { opacity:.8; font-size:12px; }
  </style>
</head>
<body>
  <div id="ui">
    <div>
      <div class="label">テンプレJSON</div>
      <input id="jsonFile" type="file" accept="application/json" />
    </div>

    <div>
      <div class="label">差し替え先スロット</div>
      <select id="slotSelect"></select>
    </div>

    <div>
      <div class="label">画像(PNG/WebP/JPG)</div>
      <input id="imgFile" type="file" accept="image/*" />
    </div>

    <button id="applyImg">差し替え</button>
    <button id="resetSlot">このスロットをリセット</button>

    <span style="flex:1"></span>

    <button id="play">Play</button>
    <button id="pause">Pause</button>
    <button id="restart">Restart</button>
  </div>

  <div id="stage"></div>

  <script src="https://cdn.jsdelivr.net/npm/pixi.js@8/dist/pixi.min.js"></script>
  <script>
    // ---- Helpers ----
    const clamp01 = (x) => Math.max(0, Math.min(1, x));
    const toRad = (deg) => deg * Math.PI / 180;

    function hexToRgba(hex) {
      if (typeof hex !== "string" || !hex.startsWith("#")) return { r:255, g:255, b:255, a:1 };
      const h = hex.slice(1);
      if (h.length === 8) {
        const a = parseInt(h.slice(0,2), 16) / 255;
        const r = parseInt(h.slice(2,4), 16);
        const g = parseInt(h.slice(4,6), 16);
        const b = parseInt(h.slice(6,8), 16);
        return { r,g,b,a };
      }
      if (h.length === 6) {
        const r = parseInt(h.slice(0,2), 16);
        const g = parseInt(h.slice(2,4), 16);
        const b = parseInt(h.slice(4,6), 16);
        return { r,g,b,a:1 };
      }
      return { r:255, g:255, b:255, a:1 };
    }
    const rgbToTint = (r,g,b) => (r<<16) | (g<<8) | b;

    // ---- Cubic Bezier easing (minimal) ----
    function makeCubicBezier(x1, y1, x2, y2) {
      const cx = 3*x1, bx = 3*(x2-x1)-cx, ax = 1-cx-bx;
      const cy = 3*y1, by = 3*(y2-y1)-cy, ay = 1-cy-by;
      const sampleX = (t)=>((ax*t+bx)*t+cx)*t;
      const sampleY = (t)=>((ay*t+by)*t+cy)*t;
      const derivX  = (t)=>(3*ax*t+2*bx)*t+cx;

      function solveX(x) {
        let t = x;
        for (let i=0;i<6;i++){
          const dx = sampleX(t)-x;
          const d  = derivX(t);
          if (Math.abs(dx) < 1e-6) return t;
          if (Math.abs(d)  < 1e-6) break;
          t = t - dx/d;
        }
        let t0=0,t1=1; t=x;
        for (let i=0;i<20;i++){
          const dx = sampleX(t)-x;
          if (Math.abs(dx) < 1e-6) return t;
          if (dx > 0) t1=t; else t0=t;
          t = (t0+t1)/2;
        }
        return t;
      }
      return (x)=>{
        x = clamp01(x);
        const t = solveX(x);
        return clamp01(sampleY(t));
      };
    }
    function parseEase(e) {
      if (!e) return null;
      const m = String(e).match(/^cubicBezier\(([-\d.]+),([-\d.]+),([-\d.]+),([-\d.]+)\)$/);
      if (!m) return null;
      return makeCubicBezier(+m[1],+m[2],+m[3],+m[4]);
    }

    // ---- Keyframe sampling ----
    function sampleTrack(track, t) {
      if (!track || track.length === 0) return null;
      if (t <= track[0].t) return track[0].v;
      if (t >= track[track.length-1].t) return track[track.length-1].v;

      let i=0;
      for (; i<track.length-1; i++){
        if (t >= track[i].t && t <= track[i+1].t) break;
      }
      const k0 = track[i], k1 = track[i+1];
      const span = (k1.t - k0.t) || 1e-6;
      let u = (t - k0.t) / span;

      // cubicBezierのみ対応。local系は無視＝linear
      const easeFn = parseEase(k1.ease) || parseEase(k0.ease);
      if (easeFn) u = easeFn(u);

      const v0 = k0.v, v1 = k1.v;

      if (typeof v0 === "number" && typeof v1 === "number")
        return v0 + (v1 - v0) * u;

      if (Array.isArray(v0) && Array.isArray(v1)) {
        const n = Math.min(v0.length, v1.length);
        const out = new Array(n);
        for (let j=0; j<n; j++) out[j] = v0[j] + (v1[j] - v0[j]) * u;
        return out;
      }

      if (typeof v0 === "string" && typeof v1 === "string")
        return (u < 0.5) ? v0 : v1;

      return v0;
    }

    // ---- Pixi setup ----
    const app = new PIXI.Application();
    await app.init({ resizeTo: window, backgroundAlpha: 0, antialias: true });
    document.getElementById("stage").appendChild(app.canvas);

    // ---- Player state ----
    let template = null;
    let playing = true;
    let timeSec = 0;
    let durationSec = 2;

    // slotId -> { container, placeholderGraphics, sprite|null }
    const slotNodes = new Map();

    function clearScene() {
      app.stage.removeChildren();
      slotNodes.clear();
      document.getElementById("slotSelect").innerHTML = "";
    }

    function addSlotOption(slotId, label) {
      const sel = document.getElementById("slotSelect");
      const opt = document.createElement("option");
      opt.value = slotId;
      opt.textContent = label ? `${label} (${slotId})` : slotId;
      sel.appendChild(opt);
    }

    function buildPlaceholder(slotId, slot, tracks) {
      const g = new PIXI.Graphics();

      // プレースホルダサイズ（後でslotにサイズを入れたらここを反映）
      const w = 220, h = 140;

      const fc = (tracks.fillColor && tracks.fillColor[0]) ? tracks.fillColor[0].v : slot.fillColor;
      const rgba = hexToRgba(fc || "#FFFFFFFF");

      g.clear();
      g.beginFill(rgbToTint(rgba.r, rgba.g, rgba.b), rgba.a);

      if (slot.type === ".circle") g.drawCircle(0, 0, 100);
      else g.drawRect(-w/2, -h/2, w, h);

      g.endFill();
      return g;
    }

    function buildSceneFromTemplate(tpl) {
      clearScene();
      template = tpl;
      durationSec = tpl?.meta?.duration ?? 2;

      const slots = tpl.slots || {};
      for (const [slotId, slot] of Object.entries(slots)) {
        const tracks = tpl.tracks?.[slotId] || {};

        // containerでまとめる（後で入れ替えしやすい）
        const c = new PIXI.Container();

        // まずプレースホルダ
        const placeholder = buildPlaceholder(slotId, slot, tracks);
        c.addChild(placeholder);

        // anchor/pivotは「まず中心」固定（ズレる問題は後で詰める）
        // Spriteにした時も anchor=0.5,0.5 で中心合わせにする

        app.stage.sortableChildren = true;
        app.stage.addChild(c);
        slotNodes.set(slotId, { container: c, placeholder, sprite: null });
        c.zIndex = slot.z ?? 0;

        addSlotOption(slotId, slot.label || slotId);
      }

      // 初期適用
      timeSec = 0;
      applyAtTime(0);
    }

function fitSpriteToBaseSize(sprite, baseSize, fit = "contain") {
  if (!baseSize || !baseSize.w || !baseSize.h) return;

  // テクスチャ本来のサイズ
  const tw = sprite.texture.width;
  const th = sprite.texture.height;
  if (!tw || !th) return;

  const sx = baseSize.w / tw;
  const sy = baseSize.h / th;

  let s = 1;
  if (fit === "cover") s = Math.max(sx, sy);
  else if (fit === "stretch") {
    sprite.scale.set(sx, sy);
    return;
  } else {
    // contain（デフォ）
    s = Math.min(sx, sy);
  }
  sprite.scale.set(s, s);
}
    
function setSlotTexture(slotId, texture) {
  const entry = slotNodes.get(slotId);
  if (!entry) return;

  const slot = template?.slots?.[slotId] || {};
  const tr = template?.tracks?.[slotId] || {};

  // 既存sprite削除
  if (entry.sprite) {
    entry.container.removeChild(entry.sprite);
    entry.sprite.destroy({ children: true });
    entry.sprite = null;
  }

  // placeholderを隠す
  entry.placeholder.visible = false;

  const sp = new PIXI.Sprite(texture);
  sp.anchor.set(0.5, 0.5); // 中心

  // ★ここが肝：スロット基準サイズにフィット
  const baseSize = slot.baseSize || null;
  const fit = slot.fit || "contain";
  fitSpriteToBaseSize(sp, baseSize, fit);

  entry.container.addChild(sp);
  entry.sprite = sp;

  // fillColorなどの影響はSpriteには当てない（必要なら後でフィルタ等）
}
    
    function resetSlot(slotId) {
      const entry = slotNodes.get(slotId);
      if (!entry) return;
      if (entry.sprite) {
        entry.container.removeChild(entry.sprite);
        entry.sprite.destroy({ children: true });
        entry.sprite = null;
      }
      entry.placeholder.visible = true;
    }

    function applyAtTime(t) {
      if (!template) return;

      for (const [slotId, entry] of slotNodes.entries()) {
        const c = entry.container;
        const tr = template.tracks?.[slotId] || {};

        const pos = sampleTrack(tr.position, t);
        if (pos) c.position.set(pos[0], pos[1]);

        const sc = sampleTrack(tr.scale, t);
        if (sc) c.scale.set(sc[0], sc[1]);

        const rot = sampleTrack(tr.rotation, t);
        if (rot != null) c.rotation = toRad(rot);

        const op = sampleTrack(tr.opacity, t);
        if (op != null) c.alpha = op;

        const sk = sampleTrack(tr.skew, t);
        if (sk) c.skew.set(sk[0], sk[1]);

        // fillColor変化：spriteが無いスロットだけプレースホルダ塗り直し
        if (!entry.sprite) {
          const col = sampleTrack(tr.fillColor, t);
          if (col) {
            const rgba = hexToRgba(col);
            const slot = template.slots[slotId];
            const w = 220, h = 140;
            entry.placeholder.clear();
            entry.placeholder.beginFill(rgbToTint(rgba.r, rgba.g, rgba.b), rgba.a);
            if (slot?.type === ".circle") entry.placeholder.drawCircle(0, 0, 100);
            else entry.placeholder.drawRect(-w/2, -h/2, w, h);
            entry.placeholder.endFill();
          }
        }
      }
    }

    // ---- Loop ----
    let last = performance.now();
    app.ticker.add(() => {
      const now = performance.now();
      const dt = (now - last) / 1000;
      last = now;

      if (playing && template) {
        timeSec += dt;
        if (durationSec > 0 && timeSec > durationSec) timeSec = timeSec % durationSec;
        applyAtTime(timeSec);
      }
    });

    // ---- UI ----
    document.getElementById("play").onclick = () => playing = true;
    document.getElementById("pause").onclick = () => playing = false;
    document.getElementById("restart").onclick = () => { timeSec = 0; applyAtTime(0); };

    document.getElementById("jsonFile").addEventListener("change", async (ev) => {
      const file = ev.target.files?.[0];
      if (!file) return;
      const tpl = JSON.parse(await file.text());
      buildSceneFromTemplate(tpl);
    });

    let lastImageFile = null;
    document.getElementById("imgFile").addEventListener("change", (ev) => {
      lastImageFile = ev.target.files?.[0] || null;
    });

    document.getElementById("applyImg").onclick = async () => {
      if (!template) return alert("先にテンプレJSONを読み込んで");
      const slotId = document.getElementById("slotSelect").value;
      if (!slotId) return alert("スロット選んで");
      if (!lastImageFile) return alert("画像ファイル選んで");

      const url = URL.createObjectURL(lastImageFile);
      const tex = await PIXI.Assets.load(url);
      setSlotTexture(slotId, tex);

      // すぐ反映
      applyAtTime(timeSec);
    };

    document.getElementById("resetSlot").onclick = () => {
      const slotId = document.getElementById("slotSelect").value;
      if (!slotId) return;
      resetSlot(slotId);
      applyAtTime(timeSec);
    };
  </script>
</body>
</html>
